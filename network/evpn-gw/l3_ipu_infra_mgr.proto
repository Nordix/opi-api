/*-
 * ============LICENSE_START=======================================================
 *  Copyright (C) 2023 Nordix Foundation.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * ============LICENSE_END=========================================================
 */

syntax = "proto3";

package evpn_gw.l3;

import "google/protobuf/empty.proto";

/* ------------------------------------------------------------------------ */

message IpAddressMasklen {
    string ip_addr = 1;
    uint32 len = 2;             // Length of the subnet prefix mask
}


/* ------------------------------------------------------------------------ */

service VrfService {
    // Management of Vrf Resources
    rpc CreateVrf(VrfInfo) returns (CreateVrfResult);
    rpc ListVrf(google.protobuf.Empty) returns (ListVrfResult);
    rpc GetVrf(VrfId) returns (GetVrfResult);
    rpc DeleteVrf(VrfId) returns (DeleteVrfResult);
}

message VrfId {
	string name = 1;
}

message VrfInfo {
    string name = 1;                  // Key, also used as name of the Linux vrf device (max 9 chars)
    uint32 vni = 2;                   // Optional: VXLAN VNI for L3 EVPN. Also used as EVPN route target
    uint32 routing_table = 3;         // Optional: Linux routing table number (range 1001-3999). Defaults to vni
    string loopback_ip = 4;           // IPv4 or IPv6 loopback address. Also serves as basis for RD in FRR
    string vtep_ip = 5;               // Optional: IPv4 or IPv6 IP address for the VXLAN TEP
    uint32 local_as = 6;              // Read-only: Local AS configured for VRF
    string rd = 7;                    // Read-only: Route distinguisher chosen by FRR
    string rmac = 8;                  // Read-only: Router MAC address of the VRF
    repeated string import_rts = 9;   // Read-only: List of import RTs chosen by FRR
    repeated string export_rts = 10;  // Read-only: List of export RTs chosen by FRR
    repeated uint32 vlan_ids = 11;    // Read-only: List of connected LogicalBridges
}

message CreateVrfResult {
    enum ErrorCode {
        OK = 0;
        INVALID_NAME = 1;
        VRF_EXISTS = 2;
        INVALID_VNI = 3;
        VNI_EXISTS = 4;
        INVALID_ROUTING_TABLE = 5;
        ROUTING_TABLE_BUSY = 6;
        INVALID_LOOPBACK_IP = 7;
        LOOPBACK_IP_BUSY = 8;
        INVALID_VTEP_IP = 9;
        VTEP_IP_NOT_FOUND = 10;
        CONFIGURATION_ERROR = 11;
    }
    ErrorCode error_code = 1;
    string details = 2;
}

message ListVrfResult {
    repeated VrfInfo vrf = 1;
}

message GetVrfResult {
    enum ErrorCode {
        OK = 0;
        VRF_NOT_FOUND = 1;
    }
    ErrorCode error_code = 1;
    string details = 2;
    VrfInfo vrf = 3;
}

message DeleteVrfResult {
    enum ErrorCode {
        OK = 0;
        VRF_NOT_FOUND = 1;
        BRIDGES_EXIST_ON_VRF = 2;
        CONFIGURATION_ERROR = 3;
    }
    ErrorCode error_code = 1;
    string details = 2;
}

/* ------------------------------------------------------------------------ */

service SviService {
    // Management of switch virtual interfaces (SVIs) binding LogicalBridges to VRFs.
    rpc CreateSvi(SviInfo) returns (CreateSviResult);
    rpc ListSvi(google.protobuf.Empty) returns (ListSviResult);
    rpc GetSvi(SviId) returns (GetSviResult);
    rpc DeleteSvi(SviId) returns (DeleteSviResult);
}

message SviId {
    string vrf = 1;             // Key (name) of the VRF
    uint32 vlan_id = 2;         // Key of the LogicalBridge
}

message SviInfo {
    string vrf = 1;                        // Name of the VRF
    uint32 vlan_id = 2;                    // Key of the LogicalBridge
    string mac_address = 3;                // Use "aa:bb:cc:dd:ee:ff" format. Randomly assigned if not specified
    repeated IpAddressMasklen gw_ip = 4;   // The GW IP addresses with masks assigned to the SVI
    bool enable_bgp = 5;                   // Optional: Set to true to enable BGP peering with VRF on SVI
    uint32 remote_as = 6;                  // Conditional: The remote AS used by BGP speakers on LB (1-65535)
}

message CreateSviResult {
    enum ErrorCode {
        OK = 0;
        SVI_EXISTS = 1;
        INVALID_VLAN_ID = 2;
        VRF_NOT_FOUND = 3;
        VLAN_ID_NOT_FOUND = 4;
        INVALID_MAC_ADDRESS = 5;
        INVALID_IP_ADDRESS = 6;
        CONFIGURATION_ERROR = 7;
        HW_OFFLOAD_ERROR = 8;
        INVALID_ASN = 9;
    }
    ErrorCode error_code = 1;
    string details = 2;
    SviInfo svi = 3;
}

message ListSviResult {
    repeated SviInfo svis = 1;
}

message GetSviResult {
    enum ErrorCode {
        OK = 0;
        SVI_NOT_FOUND = 1;
    }
    ErrorCode error_code = 1;
    string details = 2;
    SviInfo svi = 3;
}

message DeleteSviResult {
    enum ErrorCode {
        OK = 0;
        SVI_NOT_FOUND = 1;
        HW_OFFLOAD_ERROR = 2;
        CONFIGURATION_ERROR = 3;

    }
    ErrorCode error_code = 1;
    string details = 2;
}
