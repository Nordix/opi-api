// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: l3_xpu_infra_mgr.proto

package opi_api.network.evpn_gw.v1alpha1;

public interface SviOrBuilder extends
    // @@protoc_insertion_point(interface_extends:opi_api.network.evpn_gw.v1alpha1.Svi)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Name of the VRF
   * </pre>
   *
   * <code>string vrf = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The vrf.
   */
  java.lang.String getVrf();
  /**
   * <pre>
   * Name of the VRF
   * </pre>
   *
   * <code>string vrf = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The bytes for vrf.
   */
  com.google.protobuf.ByteString
      getVrfBytes();

  /**
   * <pre>
   * Key of the LogicalBridge
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: vlan cannot be negative number. --)
   * </pre>
   *
   * <code>uint32 vlan_id = 2 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The vlanId.
   */
  int getVlanId();

  /**
   * <pre>
   * Use "aa:bb:cc:dd:ee:ff" format. Randomly assigned if not specified
   * </pre>
   *
   * <code>string mac_address = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The macAddress.
   */
  java.lang.String getMacAddress();
  /**
   * <pre>
   * Use "aa:bb:cc:dd:ee:ff" format. Randomly assigned if not specified
   * </pre>
   *
   * <code>string mac_address = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The bytes for macAddress.
   */
  com.google.protobuf.ByteString
      getMacAddressBytes();

  /**
   * <pre>
   * The GW IP addresses with masks assigned to the SVI
   * </pre>
   *
   * <code>repeated .opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen gw_ip = 4 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  java.util.List<opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen> 
      getGwIpList();
  /**
   * <pre>
   * The GW IP addresses with masks assigned to the SVI
   * </pre>
   *
   * <code>repeated .opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen gw_ip = 4 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen getGwIp(int index);
  /**
   * <pre>
   * The GW IP addresses with masks assigned to the SVI
   * </pre>
   *
   * <code>repeated .opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen gw_ip = 4 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  int getGwIpCount();
  /**
   * <pre>
   * The GW IP addresses with masks assigned to the SVI
   * </pre>
   *
   * <code>repeated .opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen gw_ip = 4 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  java.util.List<? extends opi_api.network.evpn_gw.v1alpha1.IpAddressMasklenOrBuilder> 
      getGwIpOrBuilderList();
  /**
   * <pre>
   * The GW IP addresses with masks assigned to the SVI
   * </pre>
   *
   * <code>repeated .opi_api.network.evpn_gw.v1alpha1.IpAddressMasklen gw_ip = 4 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  opi_api.network.evpn_gw.v1alpha1.IpAddressMasklenOrBuilder getGwIpOrBuilder(
      int index);

  /**
   * <pre>
   * Set to true to enable BGP peering with VRF on SVI
   * </pre>
   *
   * <code>bool enable_bgp = 5;</code>
   * @return The enableBgp.
   */
  boolean getEnableBgp();

  /**
   * <pre>
   * Conditional: The remote AS used by BGP speakers on LB (1-65535)
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: remote_as cannot be negative number. --)
   * </pre>
   *
   * <code>uint32 remote_as = 6;</code>
   * @return The remoteAs.
   */
  int getRemoteAs();
}
